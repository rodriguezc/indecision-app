https://www.udemy.com/react-2nd-edition/learn/v4/t/lecture/7707632?start=0

###Evaluation REACT###

3 raisons d'apprendre react:
-learning curve: rapide
-community:  Une des meilleurs. Stack overflow Beaucoup de librairies. Facebook,  neflix, uber -> investissent dans cette techno
-speed of react: Orienté composant. On casse une grosse applications en petit composants. 


Visual studio:

Node: Javascript on the server
Plugin : emmet

prérequis:
nodejs
yarn (npm install -g yarn)

Exercice 1:
http://indecision.mead.io/
https://github.com/andrewjmead/react-course-2-indecision-app


mkdir indecision-app
cd indecision-app
mkdkir public
cd public
touch index.html

liveserver:  yarn global add live-server
live-server public


  <script src="https://unpkg.com/react@15/dist/react.js"></script> <!-- Moteur de react -->
  <script src="https://unpkg.com/react-dom@15/dist/react.js"></script> <!-- React avec le browser--> 



  Dans la console Chrome on peut lancer des commandes:
  React & ReactRom --> savoir si react existe
  
  // JSX = JavaScript XML -> Fournit p
  ar react --> Beaucoup plus facile de faire des templates - fantastique 


Pour que JSX fonctionne: Il faut le compiler -->
Avoir babbel


var template = <p>This is JSX from app.js! </p>; 						   --> Le browser comprend pas
var template = React.createElement("p", null, "This is JSX from app.js! ") --> Le browser comprend

Exemple hyper basique:
var template = React.createElement("p", null, "This is JSX from app.js! ");
var appRoot = document.getElementById("app");

ReactDOM.render(template, appRoot);


Setting up babbel:
http://babeljs.io/docs/plugins/preset-react/

-->
Lance les commandes:
yarn global add babel-cli@6.24.1
babel --help
Installer les presets babel:
yarn init 
--> Crée un fichier package.json
yarn add babel-preset-react@6.24.1
yarn add babel-preset-env@1.5.2

yarn.lock --> Permet d'avoir exactement les mêmes dépendances dans toutes les machines, environnements, etc.

Compiler avec babel:
babel src/app.js  --presets=env,react --out-file=public/scripts/app.js

-->Compile dès que le fichier source change
babel src/app.js  --presets=env,react --out-file=public/scripts/app.js --watch
--> On utilise en même temps live-server public


nodes_modules : ne doit pas être commité.  Le fichier .lock doit être par contre commité pour être sûr des versions
Si on supprime node_modules il faut refaire la commande: yarn install


#Plugins recommandés: 
Babel ES6 ES7
Beautify css/sass/
Duplicate action
ESLint
GIt history (git log)
Path intellisense
Sass Lint
SCSS IntelliSense
Sublime Text Keymap


JSX: Il doit y avoir forcément un élément ROOT
var template = (
  <div>
    <h1>Indecision App</h1>
    <p>This is some info</p>
  </div>
);
Plus lisible que
var template = 
  <div>
    <h1>Indecision App</h1>
    <p>This is some info</p>
  </div>
;
    <h1>{user.name}</h1> --> OK
	    <h1>{user}</h1> --> KO : React ne veut pas d un objet . Voir console


Conditional rendering:

if statement
ternary operators
logical and operator







<h1>{}</h1> {} --> {} Any javascript expression    
<h1>{userName.toUpperCase()}</h1>



function getLocation() {
  return "Unknown";
}
<p>Location: {getLocation()}</p>


<p>Location: {getLocation(user.Location)}</p>
function getLocation(location) {
  if (location) {
    return location;
  }
  return "Unknown";
}

Cacher tout un élément:

    {<h3>My h3</h3>}

function getLocation(location) {
  if (location) {
    return <p>Location: {location}</p>;
  }
  return undefined; //React sait qu il ne doit rien afficher dans ce cas. Facultatif de retourner undefined
}

var templateTwo = (
  <div>
    <h1>{user.name}</h1>
    <p>Age: {user.age}</p>
    {getLocation(user.location)} == Aero function
  </div>
);	
	

Termary operator (more concise): 
true ? 'Andrew' : 'Anonymous'


false / true / null ne sont pas affichés par JSX

	

	Logical and operator:
	true && 'Some Age' --> retourne 'Some age'
	false && 'Some age' --> Retourne 'false'
	
{user.age >= 18 &&  <p>Age: {user.age}</p>}

{user.age && user.age >= 18 && <p>Age: {user.age}</p>}


####################################
ES6:
Problèmes du var:
var nameVar = "Andrew";
var nameVar = "Mike";
On peut le déclarer plusieurs fois en plus de réaissigner sa valeur

A l'intérieur d'une fonction, var est visible au niveau de la fonction.

Autre exemple tordu:
var fullName = "Andrew Mead";

if (fullName) {
  var firstName = fullName.split(" ")[0];
}

console.log(firstName); --> Firstname est accessible
Il est donc function scoped. Let et const sont block scoped


let:
let nameLet = "Jen";
let nameLet = "toto";
-->
 Duplicate declaration "nameLet" déclenché par le compilateur
 

const:
const nameConst = "Franck";
const nameConst = "Gunther";
On ne peut pas redéclarer
-->
 Duplicate declaration
Ni réassigner la valeur (= final)


--> NE PLUS UTILISER VAR mais utiliser CONST ET LET


####################################

arrow function =  lambdas

On ne peut pas leur donner un nom, elles sont anonymes et associées à une variable

const squareArrow = x => {
  return x * x;
};
En plus concis:
const squareArrow = (x) => x*x;



Différences arrow functions et es5 functions:
Dans arrow function: il n'y a plus the "arguments" object donc:
const add = function(a, b) {
  console.log(arguments);
  return a + b;
};

console.log(add(55, 1, 3));

Maintenant:
const add = (a, b) => {
  console.log(arguments);
  return a + b;
};
--> CA PLANTE : arguments undefined


Pareil avec les fonctions:
ES5:

const user = {
  name: "Andrew",
  cities: ["Geneva", "Lausanne", "Dublin"],
  printPlacesLived: function() {
    console.log(this.name);
    console.log(this.cities);
  }
};
user.printPlacesLived();
//this est bien relatif à l'objet contenant la fonction.

const user = {
  name: "Andrew",
  cities: ["Geneva", "Lausanne", "Dublin"],
  printPlacesLived: function() {
    console.log(this.name);
    console.log(this.cities);

    this.cities.forEach(function(city) {
      console.log(this.name + " has lived in " + city);
    });
  }
};

--> this.name dans le foreach ne marche plus car il n'est plus bindé par rapport à user.

Différence avec lambda: lambda ne fait pas de  binding, il reprend juste le this disponible dans le contexte où il se trouve

const user = {
  name: "Andrew",
  cities: ["Geneva", "Lausanne", "Dublin"],
  printPlacesLived: function() {
    console.log(this.name);
    console.log(this.cities);

    this.cities.forEach(city => {
      console.log(this.name + " has lived in " + city);
    });
  }
};
l'arrow function utilise le this dipsonible qui est celui de user. donc ca marche.

Par contre l'exemple suivant ne marche plus:
const user = {
  name: "Andrew",
  cities: ["Geneva", "Lausanne", "Dublin"],
  printPlacesLived: ()=> {
    console.log(this.name);
    console.log(this.cities);

    this.cities.forEach(city => {
      console.log(this.name + " has lived in " + city);
    });
  }
};
user.printPlacesLived();

DONC "this" est un objet qui se crée uniquement avec la déclaration d'une fonction ES5

Façon plus élégante d'écrire une ES5 function sans devoir déclarer "= function" (qui a donc les mêmes paramètres:
  cities: ["Geneva", "Lausanne", "Dublin"],
  printPlacesLived() {
    this.cities.forEach(city => {
      console.log(this.name + " has lived in " + city);
    });
  }
};

##################################
Utilisation du forEach VS map
 this.cities.forEach(city => {
      console.log(this.name + " has lived in " + city);
    });


const cityMessages = this.cities.map(city => {
  return this.name + " has lived in " + city;
});

avec le map on peut appliquer une transformation à l'objet et obtenir une nouvelle liste.	
C'est vraiment beaucoup utilisé ces transformations

Encore plus concis:
return this.cities.map(city => this.name + " has lived in " + city);

##################################
Events and attributes
en JSX un attribut class doit être renommé en "className"

const templateTwo = (
  <div>
    <h1>Count: {count}</h1>
    <button className="button" id="my-id">
      +1
    </button>
  </div>
);
quand on fait un console.log d un jsx, on peut ensuite regarder son contenu. Voir les "props" est très intéressant puisqu'on y retrouve les children de l'élément root, en l'occurence du div.
Voir:
https://facebook.github.io/react/docs/dom-elements.html
Les attributs identiques sont par contre devenus "camelCase"
Certains mots sont réservés en javascript, d'ou le changement class en className

const someId = "myidhere";
<button id={someId}

!! 
    <button onClick={(addOne)=>{}}>+1</button>

	Attention: éviter de déclarer la fonction anonymement mais la mettre dehors:
	const addOne = () => {
		  console.log("addOne");
		};
	    <button onClick={addOne}>+1</button>


##################################
Manual data binding

JSX n'a pas de "data binding". Changer une variable de valeur ne mets pas à jour le dom.
Pourquoi?
->

const addOne = () => {
  count++;
};

const templateTwo = (
  <div>
    <h1>Count: {count}</h1>
    <button onClick={addOne}>+1</button>
  </div>
);

console.log(templateTwo);

const appRoot = document.getElementById("app");
//ReactDOM.render(template, appRoot);
ReactDOM.render(templateTwo, appRoot);


//lors du addOne il n'y a pas de nouvel appel à la fonction "render"
//Pour résoudre:

const addOne = () => {
  count++;
  console.log("addOne", count);
  renderCounterApp();
};


const appRoot = document.getElementById("app");

const renderCounterApp = () => {
  const templateTwo = (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={addOne}>+1</button>
      <button onClick={minusOne}>-1</button>
      <button onClick={reset}>reset</button>
    </div>
  );
  ReactDOM.render(templateTwo, appRoot);
};

renderCounterApp();

Dans chrome: 
Quand on regarde le dom, ce qui "flash" est ce qui est re-rendu.
On peut penser que l'exempkle ci-dessus est coûteux, mais non:
Virtual Dom algorithms: permet de changer le minimum d'élément. Meme si on render tout. Le JSX est un objet, donc un algo est applicable.



Obtention de l'objet event:

const onFormSubmit = e => {
  e.preventDefault();
};
    <form onSubmit={onFormSubmit}>


const onFormSubmit = e => {
  e.preventDefault();
  const option = e.target.elements.option.value;  //Voir nom dans formulaire
  if(option)
  console.log(option);
};


    <form onSubmit={onFormSubmit}>
      <input type="text" name="option" />
      <button type="submit">Add option</button>
    </form>


################################################################
Arrays:

	
<p>
{[99, 98, 97, "Mike smith", null, undefined, true]}
</p>

--> null, undefined et true ne sont pas affichés, seulement:
999897Mike smith

{[<p>a</p>, <p>b</p>, <p>c</p>]}
	--> WARNING: Il faut une key sinonreact n'arrive pas à indexer
{[<p key="1">a</p>, <p key="2">b</p>, <p key="3">c</p>]}
	
Iteration:
<p>
 {numbers.map(number => {
        return <p key={number}>Number : {number}</p>;
      })}
</p>


 <ol>
        {app.options.map(option => {
          return <li key={option}>{option}</li>;
        })}
      </ol>	
	
Version plus concise:
      <ol>{app.options.map(option => <li key={option}>{option}</li>)}</ol>
	

################################################################
Visibility toggle

const renderApp = () => {
  const template = (
    <div>
      <h1>Visible toggle</h1>
      <button onClick={onToggleDetails}>Show details</button>
      {toggleDetails && <div>Some details</div>}
    </div>
  );
  console.log(ReactDOM.render(template, appRoot));
};

Attention: Faut bien mettre le template dans renderApp!!! Si on mets template en dehors il n'est pas recalculé


################################################################
### React components!
################################################################
On crée autant de composant qu'on veut pour factoriser notre JSX, qu'on a besoin sur plusieurs pages ou sur la même page
Exemple de composants
<Header />
<ProfileWidget />
<Trends />
<Trend />
<Tweet />
<DashboardPage /> Contenant tous les autres ci-dessus

Autre exemple:
<IndecisionApp />
<Header />
<Action />
<Options />
<Option />
<AddOption/>

########Création de classes############
class Person {
  constructor(name) {
    console.log(name);
  }
}

const me = new Person("Christophe Rodriguez");

class Person {
  constructor(name) {
    this.name = name || "test";
  }
}
const other = new Person();
console.log(other);
--> L'instance Person a comme nom "test"


class Person {
  constructor(name = "Anonymous") {
    this.name = name;
  }
}
--> Valeur par défaut


Déclarer une méthode:
class Person {
  constructor(name = "Anonymous") {
    this.name = name;
  }

  getGreeting() {
    return "Hi";
  }
}

Backticks ES6:   `` 
class Person {
  constructor(name = "Anonymous") {
    this.name = name;
  }

  getGreeting() {
    // return "Hi. I am  " + this.name + "!";
    return `Hi. I am ${this.name}!`;
  }
}

Extension de classe:
class Student extends Person {
  constructor(name, age, major) {
    super(name, age);
    this.major = major;
  }
}


Flip flap:
!'' -> retourne false
!!'salut' -> retourne true
!'salut'-> reetourne false

!!'' -> retourne false
!''-> reetourne true

!!this.name Permet d'avoir toujours true ou false. meme si this.name est undefined


My first component:
class Header extends React.Component {
  render() {
    return <p>This is from Header</p>;
  }
}

const jsx = (
  <div>
    <h1>Title</h1>
	<Header />
  </div>
);

ReactDOM.render(jsx, document.getElementById("app"));






Autre exemple:
class IndecisionApp extends React.Component {
  render() {
    return (
      <div>
        <Header />
        <Action />
        <Options />
        <AddOption />
      </div>
    );
  }
}
ReactDOM.render(<IndecisionApp />, document.getElementById("app"));


######COMPONENTS PROPS###############################################
<Header title="Test value" />

class Header extends React.Component {
  render() {
    console.log(this.props);
    return (
      <div>
        <h1>{this.props.title}</h1>
        <h2>Put your life in the hands of a computer</h2>
      </div>
    );
  }
}
OU autre façon:
class IndecisionApp extends React.Component {
  render() {
    const title = "Indecision";
    return (
      <div>
        <Header title={title} />
        <Action />
        <Options />
        <AddOption />
      </div>
    );
  }
}

Encore un exemple:
class IndecisionApp extends React.Component {
  render() {
    const title = "Indecision";
    const subtitle = "Put your life in the hands of a computer";
    const options = ["Thing one", "Thing two", "Thing four"];
    return (
      <div>
        <Header title={title} subtitle={subtitle} />
        <Action />
        <Options options={options} />
        <AddOption />
      </div>
    );
  }
}

class Options extends React.Component {
  render() {
    return (
      <div>
        Options component here: {this.props.options.length}
        <Option />
      </div>
    );
  }
}


######EVENT HANDLERS###############################################
	